<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXELS - MINT</title>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --punk-bg: #638596;
            --punk-orange: #ff8800;
            --punk-cyan: #00ddff;
            --punk-black: #000;
            --punk-white: #e8e8e0;
            --punk-green: #44ff44;
        }
        
        body {
            font-family: 'Courier Prime', monospace;
            background: var(--punk-bg);
            color: var(--punk-black);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            max-width: 600px;
            width: 100%;
            background: var(--punk-white);
            border: 4px solid var(--punk-black);
            padding: 40px;
        }
        
        h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 2rem;
            color: var(--punk-black);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 var(--punk-orange);
        }
        
        .subtitle {
            text-align: center;
            font-size: 0.9rem;
            margin-bottom: 30px;
            padding: 10px;
            background: var(--punk-orange);
            border: 2px solid var(--punk-black);
            font-weight: 700;
        }
        
        .status {
            padding: 15px;
            background: var(--punk-cyan);
            border: 3px solid var(--punk-black);
            margin-bottom: 20px;
            font-weight: 700;
            text-align: center;
        }
        
        .status.success {
            background: var(--punk-green);
        }
        
        .status.error {
            background: #ff0044;
            color: white;
        }
        
        input {
            width: 100%;
            padding: 15px;
            border: 3px solid var(--punk-black);
            font-family: 'Courier Prime', monospace;
            font-size: 1rem;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        button {
            width: 100%;
            padding: 15px;
            background: var(--punk-orange);
            border: 3px solid var(--punk-black);
            font-family: 'Press Start 2P', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            margin-bottom: 10px;
            color: var(--punk-black);
        }
        
        button:hover:not(:disabled) {
            transform: translate(-3px, -3px);
            box-shadow: 3px 3px 0 var(--punk-black);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.secondary {
            background: var(--punk-white);
        }
        
        button.wallet-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        
        .wallet-icon {
            width: 24px;
            height: 24px;
        }
        
        .info {
            font-size: 0.85rem;
            padding: 15px;
            background: var(--punk-bg);
            border: 2px solid var(--punk-black);
            margin-top: 20px;
            line-height: 1.6;
        }
        
        .info a {
            color: var(--punk-orange);
            text-decoration: none;
            font-weight: 700;
        }
        
        .info a:hover {
            text-decoration: underline;
        }
        
        .warning {
            background: #ffdd00;
            padding: 15px;
            border: 3px solid var(--punk-black);
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .wallet-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .wallet-modal.show {
            display: flex;
        }
        
        .wallet-modal-content {
            background: var(--punk-white);
            border: 4px solid var(--punk-black);
            padding: 30px;
            max-width: 400px;
            width: 90%;
        }
        
        .wallet-modal h2 {
            font-family: 'Press Start 2P', monospace;
            font-size: 1.2rem;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .close-modal {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PIXELS</h1>
        <div class="subtitle">üî• ETHEREUM MAINNET</div>
        
        <div class="warning">
            ‚ö†Ô∏è REAL MONEY - REAL NFTs<br>
            This is on Ethereum mainnet. Transactions cost real ETH.
        </div>
        
        <div class="status" id="status">Connect your wallet to start</div>
        
        <div id="app">
            <div id="connectSection">
                <button onclick="showWalletModal()" class="wallet-btn">
                    CONNECT WALLET
                </button>
            </div>
            
            <div id="mintSection" style="display: none;">
                <input type="text" id="tokenInput" placeholder="Enter token ID (0-9999) or multiple: 1,2,3">
                <button onclick="mint()" id="mintBtn">MINT (0.0005 ETH each)</button>
                <button onclick="mintRandom()" class="secondary">MINT RANDOM</button>
                <button onclick="disconnect()" class="secondary">DISCONNECT</button>
            </div>
            
            <div class="info">
                <strong>Contract (Verified):</strong><br>
                <a href="https://etherscan.io/address/0x1D2b6046585602E754414f883e2989a68A0D049f" target="_blank">
                    0x1D2b...D049f
                </a><br><br>
                
                <strong>Price:</strong> 0.0005 ETH per punk ($1)<br>
                <strong>Max Per Wallet:</strong> 50 punks<br>
                <strong>Supply:</strong> 10,000 total<br>
                <strong>Network:</strong> Ethereum Mainnet<br><br>
                
                <strong>Supported Wallets:</strong><br>
                ‚Ä¢ MetaMask<br>
                ‚Ä¢ Rainbow<br>
                ‚Ä¢ Trust Wallet<br>
                ‚Ä¢ Coinbase Wallet<br>
                ‚Ä¢ Any WalletConnect wallet
            </div>
        </div>
    </div>
    
    <!-- Wallet Selection Modal -->
    <div class="wallet-modal" id="walletModal">
        <div class="wallet-modal-content">
            <span class="close-modal" onclick="hideWalletModal()">√ó</span>
            <h2>Choose Wallet</h2>
            <button onclick="connectMetaMask()" class="wallet-btn">
                ü¶ä METAMASK
            </button>
            <button onclick="connectWalletConnect()" class="wallet-btn">
                üîó WALLETCONNECT
            </button>
            <button onclick="connectCoinbase()" class="wallet-btn">
                üíô COINBASE WALLET
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    <script>
        const CONTRACT_ADDRESS = "0x1D2b6046585602E754414f883e2989a68A0D049f";
        const CONTRACT_ABI = [
            "function mint(uint256 tokenId) public payable",
            "function mintBatch(uint256[] memory tokenIds) public payable",
            "function isAvailable(uint256 tokenId) public view returns (bool)",
            "function balanceOf(address owner) public view returns (uint256)",
            "function totalSupply() public view returns (uint256)"
        ];
        const MINT_PRICE = "0.0005";
        const MAX_PER_WALLET = 50;
        
        let provider, signer, contract, userAddress, web3Provider;
        
        function showWalletModal() {
            document.getElementById('walletModal').classList.add('show');
        }
        
        function hideWalletModal() {
            document.getElementById('walletModal').classList.remove('show');
        }
        
        async function connectMetaMask() {
            if (!window.ethereum) {
                updateStatus("Install MetaMask first!", true);
                window.open("https://metamask.io/download/", "_blank");
                return;
            }
            
            try {
                hideWalletModal();
                updateStatus("Connecting to MetaMask...");
                
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                await initializeWallet();
            } catch (error) {
                console.error(error);
                updateStatus("MetaMask connection failed: " + error.message, true);
            }
        }
        
        async function connectWalletConnect() {
            try {
                hideWalletModal();
                updateStatus("Opening WalletConnect...");
                
                web3Provider = new WalletConnectProvider.default({
                    rpc: {
                        1: "https://cloudflare-eth.com" // Fallback RPC
                    },
                    chainId: 1,
                    qrcode: true
                });
                
                await web3Provider.enable();
                provider = new ethers.providers.Web3Provider(web3Provider);
                
                await initializeWallet();
                
                // Listen for disconnect
                web3Provider.on("disconnect", (code, reason) => {
                    console.log("WalletConnect disconnected", code, reason);
                    disconnect();
                });
                
            } catch (error) {
                console.error(error);
                if (error.message.includes("User closed modal")) {
                    updateStatus("Connection cancelled");
                } else {
                    updateStatus("WalletConnect failed: " + error.message, true);
                }
            }
        }
        
        async function connectCoinbase() {
            try {
                hideWalletModal();
                updateStatus("Opening Coinbase Wallet...");
                
                if (window.ethereum?.isCoinbaseWallet) {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    await initializeWallet();
                } else {
                    // Fallback to WalletConnect for mobile
                    await connectWalletConnect();
                }
            } catch (error) {
                console.error(error);
                updateStatus("Coinbase Wallet connection failed: " + error.message, true);
            }
        }
        
        async function initializeWallet() {
            try {
                signer = provider.getSigner();
                userAddress = await signer.getAddress();
                
                // Check network (skip for WalletConnect as it handles this)
                if (window.ethereum && !web3Provider) {
                    const network = await provider.getNetwork();
                    if (network.chainId !== 1) {
                        updateStatus("Switch to Ethereum Mainnet!", true);
                        
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x1' }],
                            });
                            // Reload after network switch
                            window.location.reload();
                            return;
                        } catch (switchError) {
                            updateStatus("Please switch to Ethereum Mainnet", true);
                            return;
                        }
                    }
                }
                
                // Initialize contract
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                
                // Try to get balance and total supply (with fallback)
                try {
                    const balance = await contract.balanceOf(userAddress);
                    const totalSupply = await contract.totalSupply();
                    
                    updateStatus(`Connected: ${userAddress.substr(0,6)}...${userAddress.substr(-4)} | Minted: ${balance}/${MAX_PER_WALLET} | Total: ${totalSupply}/10000`, false);
                } catch (readError) {
                    console.warn("Could not fetch stats:", readError);
                    // Still allow minting even if stats fail
                    updateStatus(`Connected: ${userAddress.substr(0,6)}...${userAddress.substr(-4)} | Ready to mint!`, false);
                }
                
                document.getElementById('connectSection').style.display = 'none';
                document.getElementById('mintSection').style.display = 'block';
                
            } catch (error) {
                console.error(error);
                updateStatus("Initialization failed: " + error.message, true);
            }
        }
        
        async function mint() {
            const input = document.getElementById('tokenInput').value.trim();
            if (!input) {
                updateStatus("Enter token ID(s)", true);
                return;
            }
            
            try {
                updateStatus("Preparing mint...");
                document.getElementById('mintBtn').disabled = true;
                
                // Parse input
                const ids = input.includes(',') 
                    ? input.split(',').map(s => parseInt(s.trim()))
                    : [parseInt(input)];
                
                // Validate IDs
                for (let id of ids) {
                    if (isNaN(id) || id < 0 || id >= 10000) {
                        updateStatus(`Invalid token ID: ${id}`, true);
                        document.getElementById('mintBtn').disabled = false;
                        return;
                    }
                }
                
                // Check availability
                updateStatus("Checking availability...");
                for (let id of ids) {
                    try {
                        const available = await contract.isAvailable(id);
                        if (!available) {
                            updateStatus(`Token #${id} already minted. Choose different ID.`, true);
                            document.getElementById('mintBtn').disabled = false;
                            return;
                        }
                    } catch (checkError) {
                        console.warn("Availability check failed, proceeding anyway:", checkError);
                    }
                }
                
                const value = ethers.utils.parseEther((MINT_PRICE * ids.length).toString());
                const valueInEth = (MINT_PRICE * ids.length).toFixed(4);
                
                updateStatus(`Confirm in wallet: ${valueInEth} ETH`);
                
                let tx;
                
                // Estimate gas first
                try {
                    let gasEstimate;
                    if (ids.length === 1) {
                        gasEstimate = await contract.estimateGas.mint(ids[0], { value });
                    } else {
                        gasEstimate = await contract.estimateGas.mintBatch(ids, { value });
                    }
                    
                    // Add 20% buffer to gas estimate
                    const gasLimit = gasEstimate.mul(120).div(100);
                    
                    if (ids.length === 1) {
                        tx = await contract.mint(ids[0], { value, gasLimit });
                    } else {
                        tx = await contract.mintBatch(ids, { value, gasLimit });
                    }
                } catch (gasError) {
                    console.warn("Gas estimation failed, using default gas limit:", gasError);
                    
                    // Fallback to hardcoded gas limit
                    const gasLimit = ids.length === 1 ? 150000 : 100000 + (ids.length * 50000);
                    
                    if (ids.length === 1) {
                        tx = await contract.mint(ids[0], { value, gasLimit });
                    } else {
                        tx = await contract.mintBatch(ids, { value, gasLimit });
                    }
                }
                
                updateStatus(`Mining tx: ${tx.hash.substr(0,10)}...`);
                const receipt = await tx.wait();
                
                updateStatus(`‚úì MINTED ${ids.join(', ')}! View on Etherscan ‚Üó`, false);
                document.getElementById('tokenInput').value = '';
                
                // Show etherscan link
                setTimeout(() => {
                    if (confirm('View transaction on Etherscan?')) {
                        window.open(`https://etherscan.io/tx/${tx.hash}`, '_blank');
                    }
                }, 2000);
                
            } catch (error) {
                console.error(error);
                if (error.code === 4001 || error.code === 'ACTION_REJECTED') {
                    updateStatus("Transaction rejected", true);
                } else if (error.message.includes("insufficient funds")) {
                    updateStatus("Insufficient ETH in wallet", true);
                } else if (error.message.includes("already minted") || error.message.includes("TokenAlreadyMinted")) {
                    updateStatus("Token already minted. Choose different ID.", true);
                } else if (error.message.includes("max per wallet") || error.message.includes("MaxPerWalletReached")) {
                    updateStatus("Max 50 per wallet reached", true);
                } else {
                    updateStatus("Mint failed. Check console for details.", true);
                }
            } finally {
                document.getElementById('mintBtn').disabled = false;
            }
        }
        
        async function mintRandom() {
            try {
                updateStatus("Finding available token...");
                let randomId;
                let attempts = 0;
                
                do {
                    randomId = Math.floor(Math.random() * 10000);
                    attempts++;
                    if (attempts > 50) {
                        updateStatus("Couldn't find available token. Try manually.", true);
                        return;
                    }
                } while (!(await contract.isAvailable(randomId)));
                
                document.getElementById('tokenInput').value = randomId;
                await mint();
            } catch (error) {
                updateStatus("Error: " + error.message, true);
            }
        }
        
        async function disconnect() {
            if (web3Provider) {
                await web3Provider.disconnect();
            }
            
            provider = null;
            signer = null;
            contract = null;
            userAddress = null;
            web3Provider = null;
            
            document.getElementById('connectSection').style.display = 'block';
            document.getElementById('mintSection').style.display = 'none';
            
            updateStatus("Connect your wallet to start");
        }
        
        function updateStatus(text, isError = false) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.className = 'status ' + (isError ? 'error' : text.includes('‚úì') ? 'success' : '');
        }
        
        // Auto-connect if previously connected
        if (window.ethereum && window.ethereum.selectedAddress) {
            connectMetaMask();
        }
        
        // Listen for account/network changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length > 0 && !web3Provider) {
                    connectMetaMask();
                } else if (accounts.length === 0) {
                    disconnect();
                }
            });
            
            window.ethereum.on('chainChanged', () => {
                window.location.reload();
            });
        }
    </script>
</body>
</html>
